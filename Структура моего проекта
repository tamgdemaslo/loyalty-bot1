–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞: 

‚îú‚îÄ‚îÄ bot
‚îÇ   ‚îú‚îÄ‚îÄ __pycache__
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ accrual.cpython-312.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.cpython-312.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db.cpython-312.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatting.cpython-312.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers.cpython-312.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ keyboards.cpython-312.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.cpython-312.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ moysklad.cpython-312.pyc
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ yclients.cpython-312.pyc
‚îÇ   ‚îú‚îÄ‚îÄ accrual.py
‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îú‚îÄ‚îÄ db.py
‚îÇ   ‚îú‚îÄ‚îÄ formatting.py
‚îÇ   ‚îú‚îÄ‚îÄ handlers.py
‚îÇ   ‚îú‚îÄ‚îÄ keyboards.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ moysklad.py
‚îÇ   ‚îî‚îÄ‚îÄ yclients.py
‚îú‚îÄ‚îÄ loyalty.db
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ token.env

/accrual.py

import logging
import asyncio
from datetime import datetime, timezone
from aiogram import Bot
from .config import BOT_TOKEN, BONUS_RATE, MS_BASE, MSK
from .db import change_balance, conn, get_tg_id_by_agent
from .formatting import fmt_money
from .moysklad import fetch_demands, fetch_demand_full
from dateutil import parser as dateparser, relativedelta

log = logging.getLogger(__name__)

def doc_age_seconds(iso: str) -> float:
    ts = dateparser.isoparse(iso).replace(tzinfo=MSK)
    return (datetime.now(MSK) - ts).total_seconds()

async def notify_user_about_demand(demand: dict, bonus_amount: int):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ –≥–æ—Ç–æ–≤–æ–π –º–∞—à–∏–Ω–µ –∏ –±–æ–Ω—É—Å–∞—Ö"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º agent_id –∏–∑ demand
        agent_id = demand["agent"]["meta"]["href"].split("/")[-1]
        # –ü–æ–ª—É—á–∞–µ–º tg_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        tg_id = get_tg_id_by_agent(agent_id)
        
        if tg_id:
            bot = Bot(token=BOT_TOKEN)
            try:
                message = (
                    "üöó <b>–í–∞—à–∞ –º–∞—à–∏–Ω–∞ –≥–æ—Ç–æ–≤–∞!</b>\n\n"
                    f"üí∞ –°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ: <b>{fmt_money(demand['sum'])}</b>\n"
                    f"‚ú® –ë—É–¥–µ—Ç –Ω–∞—á–∏—Å–ª–µ–Ω–æ –±–æ–Ω—É—Å–æ–≤: <b>{fmt_money(bonus_amount)}</b>"
                )
                await bot.send_message(
                    chat_id=tg_id,
                    text=message,
                    parse_mode="HTML"
                )
                log.info(f"Notification sent to user {tg_id}")
            except Exception as e:
                log.error(f"Failed to send notification: {e}")
            finally:
                await bot.session.close()
    except Exception as e:
        log.error(f"Error in notify_user_about_demand: {e}")

async def accrue_for_demand(demand: dict) -> int:
    aid = demand["agent"]["meta"]["href"].split("/")[-1]
    total = 0
    for p in demand["positions"]["rows"]:
        if p["assortment"]["meta"]["type"] == "service":
            continue
        total += int(p["price"] / 100 * p["quantity"] * BONUS_RATE * 100)
    if total:
        change_balance(aid, total)
        log.info("Accrued %s ‚Üí %s", fmt_money(total), aid)
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        await notify_user_about_demand(demand, total)
    return total

async def accrual_loop():
    """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è –±–æ–Ω—É—Å–æ–≤"""
    log.info("Accrual loop started...")
    while True:
        try:
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –æ—Ç–≥—Ä—É–∑–∫–∏
            demands = fetch_demands(limit=10)
            for demand in demands:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –ª–∏ —É–∂–µ —ç—Ç–∞ –æ—Ç–≥—Ä—É–∑–∫–∞
                already = conn.execute(
                    "SELECT 1 FROM accrual_log WHERE demand_id=?",
                    (demand["id"],)
                ).fetchone()
                
                if not already:
                    # –ï—Å–ª–∏ –æ—Ç–≥—Ä—É–∑–∫–∞ –Ω–æ–≤–∞—è - –Ω–∞—á–∏—Å–ª—è–µ–º –±–æ–Ω—É—Å—ã –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                    bonus_amount = await accrue_for_demand(demand)
                    if bonus_amount > 0:
                        await notify_user_about_demand(demand, bonus_amount)
                        conn.execute(
                            "INSERT INTO accrual_log(demand_id) VALUES(?)",
                            (demand["id"],)
                        )
                        conn.commit()
        
        except Exception as e:
            log.error(f"Error in accrual loop: {e}")
        
        # –ñ–¥–µ–º 5 –º–∏–Ω—É—Ç –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
        await asyncio.sleep(30)


Config 

import os
from dateutil.tz import gettz
from dotenv import load_dotenv
load_dotenv()

YCLIENTS_PARTNER_ID   = 9354
YCLIENTS_PARTNER_TOKEN = os.getenv("YCLIENTS_PARTNER_TOKEN", "mz5bf2yp97nbs4s45e9j")
BOT_TOKEN = os.getenv("BOT_TOKEN", "7914899311:AAGY4CjuMqZX3w1eS7zCM2yNMW3312xCwPE")
MS_TOKEN  = os.getenv("MS_TOKEN",  "ecfb2a801095bded8b05cabbb597bbce3dc59e73")

if not (BOT_TOKEN and MS_TOKEN):
    raise RuntimeError("–£–∫–∞–∂–∏—Ç–µ BOT_TOKEN –∏ MS_TOKEN ‚Äî –≤ .env –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è!")

# MoySklad
MS_BASE = "https://api.moysklad.ru/api/remap/1.2/entity"
HEADERS = {"Authorization": f"Bearer {MS_TOKEN}", "Accept": "application/json;charset=utf-8"}

# –õ–æ–≥–∏–∫–∞ –±–æ–Ω—É—Å–æ–≤
BONUS_RATE = 0.05        # 5 %
REDEEM_CAP = 0.30        # –º–æ–∂–Ω–æ —Å–ø–∏—Å–∞—Ç—å ‚â§ 30 %
MSK        = gettz("Europe/Moscow")          # –±–∞–∑–æ–≤—ã–π TZ
USER_TZ    = gettz("Europe/Kaliningrad")     # –¥–ª—è –≤—ã–≤–æ–¥–∞ –¥–∞—Ç

# UI
E_TRUCK, E_PHONE, E_SPARKLE, E_CAL, E_MONEY = "üöö", "üìû", "‚ú®", "üìÖ", "üí∞"
E_WRENCH = "üîß"
ODOMETER_ATTR_ID = "58075519-b48a-11ee-0a80-052a0018b89c"

DB

import sqlite3
from typing import Optional

conn = sqlite3.connect("loyalty.db")
conn.execute("PRAGMA foreign_keys=ON")

# ‚îÄ‚îÄ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –≤—Å–µ –Ω—É–∂–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏ –∏ —Ç–∞–±–ª–∏—Ü—ã –µ—Å—Ç—å ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
conn.executescript("""
CREATE TABLE IF NOT EXISTS user_map (
    tg_id    INTEGER PRIMARY KEY,
    agent_id TEXT    NOT NULL,
    phone    TEXT    DEFAULT '',
    fullname TEXT    DEFAULT ''
);

CREATE TABLE IF NOT EXISTS bonuses (
    agent_id TEXT PRIMARY KEY,
    balance  INTEGER NOT NULL DEFAULT 0
);

CREATE TABLE IF NOT EXISTS accrual_log (
    demand_id    TEXT PRIMARY KEY,
    processed_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
""")
conn.commit()
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def get_agent_id(tg_id: int) -> Optional[str]:
    row = conn.execute("SELECT agent_id FROM user_map WHERE tg_id=?", (tg_id,)).fetchone()
    return row[0] if row else None


def register_mapping(tg_id: int, agent_id: str, phone: str, fullname: str):
    conn.execute(
        """
        INSERT INTO user_map(tg_id, agent_id, phone, fullname)
        VALUES (?,?,?,?)
        ON CONFLICT(tg_id) DO UPDATE
           SET agent_id = excluded.agent_id,
               phone    = excluded.phone,
               fullname = excluded.fullname
        """,
        (tg_id, agent_id, phone, fullname),
    )
    # –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã—Ö –±–æ–Ω—É—Å–æ–≤, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤—ã–π
    conn.execute(
        """
        INSERT INTO bonuses(agent_id, balance) VALUES(?,?)
        ON CONFLICT(agent_id) DO NOTHING
        """,
        (agent_id, 10000),  # 100 –±–æ–Ω—É—Å–æ–≤ –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    )
    conn.commit()


def user_contact(tg_id: int) -> tuple[str, str]:
    row = conn.execute("SELECT phone, fullname FROM user_map WHERE tg_id=?", (tg_id,)).fetchone()
    return row if row else ("", "")


def get_balance(agent_id: str) -> int:
    row = conn.execute("SELECT balance FROM bonuses WHERE agent_id=?", (agent_id,)).fetchone()
    return row[0] if row else 0


def change_balance(agent_id: str, delta: int):
    conn.execute(
        """
        INSERT INTO bonuses(agent_id, balance) VALUES(?,?)
        ON CONFLICT(agent_id) DO UPDATE SET balance = balance + ?
        """,
        (agent_id, delta, delta),
    )
    conn.commit()


def get_tg_id_by_agent(agent_id: str) -> int | None:
    """–ü–æ–ª—É—á–∞–µ—Ç Telegram ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –µ–≥–æ agent_id"""
    row = conn.execute(
        "SELECT tg_id FROM user_map WHERE agent_id=?", 
        (agent_id,)
    ).fetchone()
    return row[0] if row else None

/formatting.py

from dateutil import parser as dateparser
from .config import MSK, USER_TZ

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –¥–∞—Ç—ã/–¥–µ–Ω—å–≥–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def fmt_date_local(iso: str) -> str:
    """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –º–æ–º–µ–Ω—Ç –∏–∑ –ú–æ–π–°–∫–ª–∞–¥–∞ (naive-MSK) –≤ –ª–æ–∫–∞–ª—å–Ω–æ–µ USER_TZ."""
    ts = dateparser.isoparse(iso).replace(tzinfo=MSK)
    return ts.astimezone(USER_TZ).strftime("%d.%m.%Y %H:%M")

def fmt_money(kop: int) -> str:
    rub = kop / 100
    return f"{rub:,.2f} ‚ÇΩ".rstrip("0").rstrip(",")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ø–æ–∑–∏—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def render_positions(rows: list) -> str:
    """
    –ü–æ–ª—É—á–∞–µ—Ç d['positions']['rows'] –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ demand –∏
    –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫—Ä–∞—Å–∏–≤—ã–π HTML-—Å–ø–∏—Å–æ–∫ –≤–∏–¥–∞:
        ‚Ä¢ –¢–æ–≤–∞—Ä ‚Äî 2 √ó 450 ‚ÇΩ = 900 ‚ÇΩ
    """
    lines: list[str] = []
    for p in rows:
        art  = p["assortment"]
        name = art.get("name", "‚Äî")
        qty  = p.get("quantity", 1)
        price_kop = p.get("price", 0)
        total_kop = int(price_kop * qty)
        lines.append(
            f"‚Ä¢ <b>{name}</b> ‚Äî {qty:g} √ó {fmt_money(price_kop)} = {fmt_money(total_kop)}"
        )
    return "\n".join(lines)

/Users/ilaeliseenko/Desktop/loyalty-bot/bot/handlers.py

import logging
import requests
from datetime import datetime, timedelta, date
from aiogram import types, F
from aiogram.enums import ContentType, ChatAction
from aiogram.filters import CommandStart
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import ReplyKeyboardMarkup, InlineKeyboardBuilder
from bot.yclients import services, staff, free_slots, book_dates, create_record, format_date_russian
from bot.db import register_mapping, user_contact
from bot.config import E_MONEY, REDEEM_CAP
from bot.db import (get_agent_id, register_mapping, get_balance, change_balance, conn)
from bot.moysklad import (find_agent_by_phone, fetch_shipments, fetch_demand_full, apply_discount)
from bot.moysklad import MS_BASE, HEADERS
from bot.formatting import fmt_money, fmt_date_local, render_positions
from bot.accrual import doc_age_seconds, accrue_for_demand

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
log = logging.getLogger(__name__)

# UUID –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –ú–æ–π–°–∫–ª–∞–¥
COMPANY_ID = 902665
VIN_ATTR_ID   = "9622737b-b47d-11ee-0a80-066f0015f528"
BRAND_ATTR_ID = "a308e9de-b47d-11ee-0a80-0d3b0016ecc6"
ODO_ATTR_ID   = "58075519-b48a-11ee-0a80-052a0018b89c"
REC_ATTR_ID   = "845f0de1-b4a6-11ee-0a80-103900016c42"

class Auth(StatesGroup):
    wait_name = State()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
MAIN_MENU_KB = ReplyKeyboardMarkup(
    keyboard=[
        [types.KeyboardButton(text="–ë–∞–ª–∞–Ω—Å"), types.KeyboardButton(text="–°–ø–∏—Å–∞—Ç—å –±–∞–ª–ª—ã")],
        [types.KeyboardButton(text="–ò—Å—Ç–æ—Ä–∏—è –ø–æ—Å–µ—â–µ–Ω–∏–π")],
        [types.KeyboardButton(text="–ó–∞–ø–∏—Å–∞—Ç—å—Å—è")],
    ],
    resize_keyboard=True,
)

def confirm_redeem_kb() -> types.InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–ø–∏—Å–∞–Ω–∏—è –±–æ–Ω—É—Å–æ–≤"""
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Å–ø–∏—Å–∞–Ω–∏–µ", callback_data="redeem_confirm")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="redeem_cancel")
    kb.adjust(1)
    return kb.as_markup()

def list_visits_kb(rows: list[dict]) -> types.InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for d in rows:
        kb.button(
            text=f"–ß–µ–∫ ‚Ññ{d.get('name') or d['id'][:8]} ¬∑ {fmt_date_local(d['moment'])}",
            callback_data=f"visit_{d['id']}",
        )
    kb.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
    kb.adjust(1)
    return kb.as_markup()


def visit_detail_kb() -> types.InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="‚óÄÔ∏è –ö —Å–ø–∏—Å–∫—É", callback_data="back_history")
    kb.button(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_main")
    kb.adjust(2)
    return kb.as_markup()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ —Ä–µ–≥–∏—Å—Ç—Ä —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def register(dp):

    # /start
    @dp.message(CommandStart())
    async def cmd_start(m: types.Message):
        aid = get_agent_id(m.from_user.id)
        if aid:
            return await m.answer(
                "‚úÖ –í—ã —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                reply_markup=MAIN_MENU_KB
            )
            
        kb = ReplyKeyboardMarkup(
            keyboard=[[types.KeyboardButton(text="–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
            resize_keyboard=True,
            one_time_keyboard=True,
        )
        await m.answer(
            "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ–Ω—É—Å–Ω—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É!\n\n"
            "–î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞:",
            reply_markup=kb
        )

    # –∫–æ–Ω—Ç–∞–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –∫–æ–Ω—Ç–∞–∫—Ç (–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @dp.message(F.content_type == ContentType.CONTACT)
    async def contact(m: types.Message, state: FSMContext):
        phone = m.contact.phone_number
        aid   = find_agent_by_phone(phone)

        # ‚îÄ‚îÄ‚îÄ –∫–ª–∏–µ–Ω—Ç —É–∂–µ –µ—Å—Ç—å –≤ –ú–æ–π–°–∫–ª–∞–¥ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if aid:
            register_mapping(
                tg_id   = m.from_user.id,
                agent_id= aid,
                phone   = phone,
                fullname= m.contact.first_name or ""
            )

            # –Ω–∞—á–∏—Å–ª–∏–º –±–æ–Ω—É—Å—ã, –µ—Å–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏–ª–∏ –ø–æ—Å–ª–µ–¥–Ω—é—é –æ—Ç–≥—Ä—É–∑–∫—É
            last = fetch_shipments(aid, limit=1)
            if last:
                did = last[0]["id"]
                already = conn.execute(
                    "SELECT 1 FROM accrual_log WHERE demand_id=?", (did,)
                ).fetchone()
                if not already:
                    full = fetch_demand_full(did)
                    if doc_age_seconds(full["moment"]) >= 300:
                        added = accrue_for_demand(full)
                        if added:
                            conn.execute(
                                "INSERT INTO accrual_log(demand_id) VALUES(?)", (did,)
                            )
                            conn.commit()
                            await m.answer(
                                f"‚úÖ –ù–∞—á–∏—Å–ª–µ–Ω–æ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –ø–æ—Å–µ—â–µ–Ω–∏–µ: {fmt_money(added)}"
                            )

            await m.answer("‚úÖ –í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                        reply_markup=MAIN_MENU_KB)
            return

        # ‚îÄ‚îÄ‚îÄ –Ω–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç: —Å–ø—Ä–∞—à–∏–≤–∞–µ–º –§–ò–û –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–º–µ—Ä –≤ FSM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        await state.set_state(Auth.wait_name)
        await state.update_data(phone=phone)          # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–º–µ—Ä
        await m.answer("–ö–∞–∫ –∫ –≤–∞–º –æ–±—Ä–∞—â–∞—Ç—å—Å—è? (–§–ò–û)")


    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ø–æ–ª—É—á–∏–ª–∏ –§–ò–û ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @dp.message(Auth.wait_name)
    async def got_name(m: types.Message, state: FSMContext):
        data  = await state.get_data()
        phone = data["phone"]
        name  = m.text.strip()

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ø—Ä–æ–±—É–µ–º —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞ –≤ –ú–æ–π–°–∫–ª–∞–¥ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        try:
            payload = {
                "name":  name,
                "phone": phone,          # –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
                "phones": [              # –æ—Å—Ç–∞—ë—Ç—Å—è –∏ –≤ –º–∞—Å—Å–∏–≤–µ phones
                    {"phone": phone}
                ]
            }
            resp = requests.post(
                f"{MS_BASE}/counterparty",
                headers=HEADERS,
                json=payload,
                timeout=10,
            )
            resp.raise_for_status()      # ‚Üë –≤—ã–±—Ä–æ—Å–∏—Ç –∏—Å–∫–ª—é—á–µ–Ω–∏–µ, –µ—Å–ª–∏ –Ω–µ 2xx
            aid = resp.json()["id"]      # id —Å–æ–∑–¥–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞

        except Exception as e:
            await m.answer(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–∞: {e}")
            return

        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–≤—è–∑—å TG ‚Üî –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç + –∫–æ–Ω—Ç–∞–∫—Ç—ã
        register_mapping(m.from_user.id, aid, phone, name)

        # –°–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã—Ö –±–æ–Ω—É—Å–æ–≤
        await m.answer("‚úÖ –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ 100 –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã—Ö –±–æ–Ω—É—Å–æ–≤!")

        await state.clear()

        await m.answer(
            "‚úÖ –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω –∏ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω.\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=MAIN_MENU_KB
        )


    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ¬´–ó–∞–ø–∏—Å–∞—Ç—å—Å—è¬ª  ‚Üí  –®–ê–ì 1: —É—Å–ª—É–≥–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @dp.message(F.text == "–ó–∞–ø–∏—Å–∞—Ç—å—Å—è")
    async def msg_booking_start(m: types.Message):
        try:
            resp = services(COMPANY_ID)
            services_list = resp["services"] if "services" in resp else resp["data"]["services"]
        except Exception as e:
            return await m.answer(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —É—Å–ª—É–≥: {e}")

        kb = InlineKeyboardBuilder()
        for svc in services_list:
            kb.button(text=svc["title"], callback_data=f"bk_srv_{svc['id']}")   # bk_srv_<srv>
        kb.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_menu")
        kb.adjust(1)
        await m.answer("–í—ã–±–µ—Ä–∏—Ç–µ —É—Å–ª—É–≥—É:", reply_markup=kb.as_markup())


    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –®–ê–ì 2: –º–∞—Å—Ç–µ—Ä ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
    @dp.callback_query(F.data.startswith("bk_srv_"))
    async def cb_choose_staff(cq: types.CallbackQuery):
        """–ü–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ —É—Å–ª—É–≥–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–∞—Å—Ç–µ—Ä–æ–≤."""
        await cq.answer()
        srv_id = int(cq.data.split("_")[2])               # bk_srv_<srv_id>

        # --- –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –º–∞—Å—Ç–µ—Ä–æ–≤ –≤ YCLIENTS ---
        try:
            raw = staff(COMPANY_ID, [srv_id])             # <‚Äî –≤–∞—à –≤—ã–∑–æ–≤ –∫ API
            # API –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –ª–∏–±–æ —Å–ø–∏—Å–æ–∫, –ª–∏–±–æ —Å–ª–æ–≤–∞—Ä—å —Å –∫–ª—é—á–∞–º–∏ data/staff
            if isinstance(raw, list):
                staff_list = raw
            elif isinstance(raw, dict):
                staff_list = (
                    raw.get("staff") or                   # { staff:[...] }
                    raw.get("data", {}).get("staff") or   # { data:{ staff:[...] } }
                    raw.get("data") or []                 # { data:[...] }
                )
            else:
                raise TypeError(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: {type(raw)}")
        except Exception as e:
            return await cq.message.answer(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤: {e}")

        if not staff_list:
            return await cq.message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–∞—Å—Ç–µ—Ä–æ–≤ –¥–ª—è —ç—Ç–æ–π —É—Å–ª—É–≥–∏ üòî")

        # --- —Å—Ç—Ä–æ–∏–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –º–∞—Å—Ç–µ—Ä–æ–≤ ---
        kb = InlineKeyboardBuilder()
        for st in staff_list:
            # –ø—Ä–æ–ø—É—Å—Ç–∏–º –≤—Å—ë, —á—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Å–ª–æ–≤–∞—Ä—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞
            if not isinstance(st, dict):
                continue
            kb.button(
                text=st.get("name", "‚Äî"),
                callback_data=f"bk_stf_{srv_id}_{st['id']}"   # bk_stf_<srv_id>_<stf_id>
            )
        kb.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_menu")
        kb.adjust(1)

        await cq.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞:", reply_markup=kb.as_markup())



    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –®–ê–ì 3: –¥–∞—Ç–∞ (7 –±–ª–∏–∂–∞–π—à–∏—Ö –¥–Ω–µ–π) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @dp.callback_query(F.data.startswith("bk_stf_"))
    async def cb_choose_day(cq: types.CallbackQuery):
        await cq.answer()
        _, _, srv_id, stf_id = cq.data.split("_", 3)
        srv_id, stf_id = int(srv_id), int(stf_id)

        today = date.today()
        dates_resp = book_dates(
            COMPANY_ID,
            service_ids=[srv_id],
            staff_id=stf_id,
            date_from=today.isoformat(),
            date_to=(today + timedelta(days=7)).isoformat(),
        )
        dates = dates_resp.get("booking_dates") or dates_resp.get("data", {}).get("booking_dates", [])

        if not dates:
            return await cq.answer("–ë–ª–∏–∂–∞–π—à–∏—Ö —Å–ª–æ—Ç–æ–≤ –Ω–µ—Ç üòî", show_alert=True)

        kb = InlineKeyboardBuilder()
        for d in dates:
            formatted_date = format_date_russian(d)
            kb.button(
                text=formatted_date,
                callback_data=f"bk_day_{srv_id}_{stf_id}_{d}",
            )
        kb.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"bk_srv_{srv_id}")
        kb.adjust(2)
        await cq.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:", reply_markup=kb.as_markup())


    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –®–ê–ì 4: –≤—Ä–µ–º—è ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @dp.callback_query(F.data.startswith("bk_day_"))
    async def cb_choose_time(cq: types.CallbackQuery):
        await cq.answer()
        _, _, srv_id, stf_id, day = cq.data.split("_", 4)
        srv_id, stf_id = int(srv_id), int(stf_id)

        try:
            slots = free_slots(COMPANY_ID, stf_id, srv_id, day)
        except Exception as e:
            return await cq.message.answer(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏: {e}")

        if not slots:
            return await cq.answer("–ù–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–µ—Ç", show_alert=True)

        kb = InlineKeyboardBuilder()
        for s in slots:
            kb.button(
                text=s["time"],
                callback_data=f"bk_tm_{srv_id}_{stf_id}_{day}_{s['datetime']}",
            )
        kb.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"bk_stf_{srv_id}_{stf_id}")
        kb.adjust(3)
        await cq.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb.as_markup())


    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –®–ê–ì 5: –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @dp.callback_query(F.data.startswith("bk_tm_"))
    async def cb_confirm_record(cq: types.CallbackQuery):
        await cq.answer()
        _, _, srv_id, stf_id, day, iso_dt = cq.data.split("_", 5)
        srv_id, stf_id = int(srv_id), int(stf_id)

        kb = InlineKeyboardBuilder()
        kb.button(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data=f"bk_ok_{srv_id}_{stf_id}_{iso_dt}")
        kb.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"bk_day_{srv_id}_{stf_id}_{day}")
        kb.adjust(1)

        await cq.message.edit_text(
            f"<b>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∑–∞–ø–∏—Å—å</b>\n"
            f"–£—Å–ª—É–≥–∞ ID: {srv_id}\n"
            f"–ú–∞—Å—Ç–µ—Ä ID: {stf_id}\n"
            f"–î–∞—Ç–∞: {day}\n"
            f"–í—Ä–µ–º—è: {iso_dt[11:16]}",
            reply_markup=kb.as_markup(),
        )


    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –®–ê–ì 6: —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @dp.callback_query(F.data.startswith("bk_ok_"))
    async def cb_make_record(cq: types.CallbackQuery, state: FSMContext):
        await cq.answer()
        _, _, srv_id, stf_id, iso_dt = cq.data.split("_", 4)
        srv_id, stf_id = int(srv_id), int(stf_id)

        phone, fullname = user_contact(cq.from_user.id)

        try:
            create_record(
                COMPANY_ID,
                phone=phone,
                fullname=fullname or "–ö–ª–∏–µ–Ω—Ç Telegram",
                email="",
                appointments=[
                    {
                        "id": 1,
                        "services": [srv_id],
                        "staff_id": stf_id,
                        "datetime": iso_dt,
                    }
                ],
            )
            await cq.message.edit_text("üéâ –ó–∞–ø–∏—Å—å —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!")
        except Exception as e:
            await cq.message.edit_text(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å: {e}")



    # –±–∞–ª–∞–Ω—Å
    @dp.message(F.text == "–ë–∞–ª–∞–Ω—Å")
    async def msg_balance(m: types.Message):
        aid = get_agent_id(m.from_user.id)
        if not aid:
            return await m.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ /start")
        await m.answer(f"–í–∞—à –±–æ–Ω—É—Å–Ω—ã–π —Å—á—ë—Ç: {fmt_money(get_balance(aid))}")

    @dp.message(F.text == "–°–ø–∏—Å–∞—Ç—å –±–∞–ª–ª—ã")
    async def msg_redeem_prompt(m: types.Message, state: FSMContext):
        aid = get_agent_id(m.from_user.id)
        if not aid:
            kb = ReplyKeyboardMarkup(
                keyboard=[[types.KeyboardButton(text="–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
                resize_keyboard=True,
                one_time_keyboard=True,
            )
            return await m.answer(
                "‚ö†Ô∏è –î–ª—è —Å–ø–∏—Å–∞–Ω–∏—è –±–∞–ª–ª–æ–≤ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è.\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞:",
                reply_markup=kb
            )

        # Get current balance
        balance = get_balance(aid)
        if balance == 0:
            return await m.answer(
                "‚ùå –ù–∞ –≤–∞—à–µ–º —Å—á—ë—Ç–µ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –±–∞–ª–ª–æ–≤",
                reply_markup=MAIN_MENU_KB
            )

        # Get last visit
        visits = fetch_shipments(aid, limit=1)
        if not visits:
            return await m.answer(
                "‚ùå –ò—Å—Ç–æ—Ä–∏—è –ø–æ—Å–µ—â–µ–Ω–∏–π –ø—É—Å—Ç–∞",
                reply_markup=MAIN_MENU_KB
            )

        # Calculate available bonus amount
        check = fetch_demand_full(visits[0]["id"])
        max_kop = int(check["sum"] * REDEEM_CAP)
        kop = min(balance, max_kop)

        message = (
            f"<b>üí≥ –°–ø–∏—Å–∞–Ω–∏–µ –±–æ–Ω—É—Å–æ–≤</b>\n\n"
            f"üí∞ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: <b>{fmt_money(balance)}</b>\n"
            f"üßæ –ß–µ–∫ ‚Ññ{check.get('name') or check['id'][:8]}\n"
            f"üíµ –°—É–º–º–∞ —á–µ–∫–∞: <b>{fmt_money(check['sum'])}</b>\n"
            f"‚ú® –î–æ—Å—Ç—É–ø–Ω–æ –∫ —Å–ø–∏—Å–∞–Ω–∏—é: <b>{fmt_money(kop)}</b>\n"
            f"‚ÑπÔ∏è –ú–æ–∂–Ω–æ —Å–ø–∏—Å–∞—Ç—å –Ω–µ –±–æ–ª–µ–µ 30% –æ—Ç —Å—É–º–º—ã —á–µ–∫–∞\n\n"
            f"–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Å–ø–∏—Å–∞–Ω–∏–µ <b>{fmt_money(kop)}</b>?"
        )

        # Store redemption data in FSM
        await state.update_data(
            check_id=check["id"],
            amount=kop
        )

        await m.answer(
            message,
            reply_markup=confirm_redeem_kb(),
            parse_mode="HTML"
        )

    async def process_redeem(m: types.Message, rub_requested: int | None):
        aid = get_agent_id(m.from_user.id)
        if not aid:
            return await m.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ /start")
        bal_kop = get_balance(aid)
        if bal_kop == 0:
            return await m.answer("–ù–∞ —Å—á—ë—Ç–µ –Ω–µ—Ç –±–∞–ª–ª–æ–≤.")

        visits = fetch_shipments(aid, limit=1)
        if not visits:
            return await m.answer("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.")
        check = fetch_demand_full(visits[0]["id"])
        max_kop = int(check["sum"] * REDEEM_CAP)
        kop = min(bal_kop, max_kop, (rub_requested or max_kop) * 100)
        if kop == 0:
            return await m.answer(
                f"–î–æ—Å—Ç—É–ø–Ω–æ –∫ —Å–ø–∏—Å–∞–Ω–∏—é: {fmt_money(max_kop)}. –ë–∞–ª–∞–Ω—Å: {fmt_money(bal_kop)}."
            )

        percent = round(kop / check["sum"] * 100, 2)
        apply_discount(check["id"], percent, check["positions"]["rows"])
        change_balance(aid, -kop)
        await m.answer(
            f"–°–ø–∏—Å–∞–Ω–æ {fmt_money(kop)} (‚âà{percent}% –æ—Ç —á–µ–∫–∞).\n"
            f"–ë–∞–ª–∞–Ω—Å: {fmt_money(bal_kop - kop)}",
            reply_markup=MAIN_MENU_KB,
        )

    @dp.callback_query(F.data == "redeem_confirm")
    async def cb_redeem_confirm(cq: types.CallbackQuery, state: FSMContext):
        aid = get_agent_id(cq.from_user.id)
        if not aid:
            await cq.answer("‚ö†Ô∏è –ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è", show_alert=True)
            return

        data = await state.get_data()
        amount = data.get("amount", 0)
        check_id = data.get("check_id")

        if not amount or not check_id:
            await cq.answer("‚ùå –û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
            return

        try:
            # Apply discount and update balance
            check = fetch_demand_full(check_id)
            percent = round(amount / check["sum"] * 100, 2)
            apply_discount(check_id, percent, check["positions"]["rows"])
            change_balance(aid, -amount)

            await cq.message.edit_text(
                f"‚úÖ –°–ø–∏—Å–∞–Ω–æ {fmt_money(amount)} (‚âà{percent}% –æ—Ç —á–µ–∫–∞)\n"
                f"üí∞ –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {fmt_money(get_balance(aid))}",
                reply_markup=None
            )
        except Exception as e:
            await cq.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}", show_alert=True)

    @dp.callback_query(F.data == "redeem_cancel")
    async def cb_redeem_cancel(cq: types.CallbackQuery):
        await cq.answer("–°–ø–∏—Å–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ")
        await cq.message.edit_text(
            "‚ùå –°–ø–∏—Å–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ",
            reply_markup=None
        )

    # –∏—Å—Ç–æ—Ä–∏—è
    @dp.message(F.text == "–ò—Å—Ç–æ—Ä–∏—è –ø–æ—Å–µ—â–µ–Ω–∏–π")
    async def msg_history(m: types.Message):
        aid = get_agent_id(m.from_user.id)
        if not aid:
            return await m.answer(
                "‚ö†Ô∏è –î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏—Å—Ç–æ—Ä–∏–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è.\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–ø–æ–ª–Ω–∏—Ç–µ /start"
            )

        visits = fetch_shipments(aid, limit=20)
        if not visits:
            return await m.answer(
                "üìù –ò—Å—Ç–æ—Ä–∏—è –ø–æ—Å–µ—â–µ–Ω–∏–π –ø–æ–∫–∞ –ø—É—Å—Ç–∞",
                reply_markup=MAIN_MENU_KB
            )

        await m.answer(
            "üìã –í—ã–±–µ—Ä–∏—Ç–µ –≤–∏–∑–∏—Ç –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–µ—Ç–∞–ª–µ–π:",
            reply_markup=list_visits_kb(visits)
        )

    # –ø—Ä–æ—Å–º–æ—Ç—Ä —á–µ–∫–∞
    @dp.callback_query(lambda c: c.data.startswith("visit_"))
    async def cb_visit(callback: types.CallbackQuery):
        vid = callback.data.replace("visit_", "")
        try:
            v = fetch_demand_full(vid)
            if not v:
                await callback.answer("‚ùå –û—Ç–≥—Ä—É–∑–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞")
                return

            text = (
                f"üìã –ß–µ–∫ ‚Ññ{v.get('name') or v['id'][:8]}\n"
                f"üìÖ {fmt_date_local(v['moment'])}\n"
                f"üí∞ –°—É–º–º–∞: {fmt_money(v['sum'])}\n\n"
                f"{render_positions(v['positions']['rows'])}"
            )
            
            await callback.message.edit_text(text)
            
        except Exception as e:
            log.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–µ—Ç–∞–ª–µ–π –æ—Ç–≥—Ä—É–∑–∫–∏: {e}")
            await callback.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –æ—Ç–≥—Ä—É–∑–∫–∏")

    # –Ω–∞–∑–∞–¥: –∏–∑ –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ —Å–ø–∏—Å–æ–∫
    @dp.callback_query(F.data == "back_history")
    async def cb_back_history(cq: types.CallbackQuery):
        aid = get_agent_id(cq.from_user.id)
        if not aid:
            return await cq.answer()
        visits = fetch_shipments(aid, limit=20)
        if not visits:
            return await cq.answer("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", show_alert=True)
        await cq.message.edit_text("–ù–µ–¥–∞–≤–Ω–∏–µ –ø–æ—Å–µ—â–µ–Ω–∏—è:", reply_markup=list_visits_kb(visits))
        await cq.answer()

    # –Ω–∞–∑–∞–¥: –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    @dp.callback_query(F.data == "back_main")
    async def cb_back_main(cq: types.CallbackQuery):
        await cq.message.edit_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=None)
        await cq.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=MAIN_MENU_KB)
        await cq.answer()

/Users/ilaeliseenko/Desktop/loyalty-bot/bot/keyboards.py

from aiogram.utils.keyboard import InlineKeyboardBuilder
from .config import E_TRUCK
from .formatting import fmt_date_local

def shipments_kb(docs):
    kb = InlineKeyboardBuilder()
    for d in docs:
        kb.button(
            text=f"{E_TRUCK} ‚Ññ{d.get('name') or d['id'][:8]} ‚Ä¢ {fmt_date_local(d['moment'])}",
            callback_data=f"ship_{d['id']}"
        )
    kb.adjust(1)
    return kb.as_markup()


/Users/ilaeliseenko/Desktop/loyalty-bot/bot/main.py

# loyalty-bot/bot/main.py
import asyncio
import logging

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.memory import MemoryStorage

from bot.config import BOT_TOKEN
from bot.handlers import register as register_handlers
from bot.accrual import accrual_loop

logging.basicConfig(
    level=logging.INFO,
    format="%(levelname)s:%(name)s: %(message)s",
)

async def main() -> None:
    if not BOT_TOKEN:
        logging.error("BOT_TOKEN is not set. Please check your configuration.")
        return

    bot = Bot(
        token=BOT_TOKEN,
        default=DefaultBotProperties(parse_mode="HTML"),
    )
    dp = Dispatcher(storage=MemoryStorage())

    # Register all handlers
    register_handlers(dp)

    async with bot:
        try:
            # Background task for bonus accrual
            asyncio.create_task(accrual_loop())
        except Exception as e:
            logging.error(f"Error in accrual_loop: {e}")

        # Remove old updates and start polling
        await bot.delete_webhook(drop_pending_updates=True)
        await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except Exception as e:
        logging.error(f"Unhandled exception: {e}")

/Users/ilaeliseenko/Desktop/loyalty-bot/bot/moysklad.py

import requests, logging
from typing import Optional
from datetime import datetime, timedelta
from .config import MS_BASE, HEADERS

MS_BASE = "https://api.moysklad.ru/api/remap/1.2"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
log = logging.getLogger(__name__)

def _get(path: str, params: dict | None = None) -> dict:
    """
    –í—ã–ø–æ–ª–Ω—è–µ—Ç GET-–∑–∞–ø—Ä–æ—Å –∫ API –ú–æ–π–°–∫–ª–∞–¥
    """
    url = f"{MS_BASE}/{path.lstrip('/')}"
    try:
        response = requests.get(
            url,
            headers=HEADERS,
            params=params or {},
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        log.error(f"MoySklad API error ({url}): {e}")
        raise

def find_agent_by_phone(phone: str) -> Optional[str]:
    digits = "".join(filter(str.isdigit, phone))
    rows = _get("counterparty", {"search": digits, "limit": 1}).get("rows", [])
    return rows[0]["id"] if rows else None

def fetch_shipments(agent_id: str, limit: int = 20, order: str = "desc") -> list[dict]:
    """–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –æ—Ç–≥—Ä—É–∑–æ–∫ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞"""
    try:
        params = {
            "filter": f"agent={MS_BASE}/entity/counterparty/{agent_id}",
            "order": f"moment,{order}",
            "limit": limit
        }
        
        result = _get("entity/demand", params)
        shipments = result.get("rows", [])
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º —É–¥–∞–ª–µ–Ω–Ω—ã–µ –æ—Ç–≥—Ä—É–∑–∫–∏
        valid_shipments = []
        for shipment in shipments:
            try:
                if fetch_demand_full(shipment["id"]):
                    valid_shipments.append(shipment)
            except Exception:
                continue
                
        return valid_shipments
        
    except Exception as e:
        log.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –æ—Ç–≥—Ä—É–∑–æ–∫: {e}")
        return []

def fetch_demand_full(did: str) -> Optional[dict]:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ç–≥—Ä—É–∑–∫–µ
    Args:
        did: ID –æ—Ç–≥—Ä—É–∑–∫–∏
    Returns:
        –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –æ—Ç–≥—Ä—É–∑–∫–∏ –∏–ª–∏ None –µ—Å–ª–∏ –æ—Ç–≥—Ä—É–∑–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞
    """
    try:
        return _get(f"entity/demand/{did}", {"expand": "positions,positions.assortment"})
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            log.warning(f"–û—Ç–≥—Ä—É–∑–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {did}")
            return None
        log.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç–≥—Ä—É–∑–∫–∏ {did}: {e}")
        raise

def apply_discount(did: str, percent: float, positions: list):
    body = {"positions": [{"id": p["id"], "discount": percent} for p in positions]}
    resp = requests.put(f"{MS_BASE}/demand/{did}", headers=HEADERS, json=body, timeout=10)
    resp.raise_for_status()

def fetch_demands(limit: int = 10) -> list[dict]:
    """
    –ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—Ç–≥—Ä—É–∑–æ–∫
    Args:
        limit: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–≥—Ä—É–∑–æ–∫
    Returns:
        –°–ø–∏—Å–æ–∫ –æ—Ç–≥—Ä—É–∑–æ–∫, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ –¥–∞—Ç–µ –ø–æ —É–±—ã–≤–∞–Ω–∏—é
    """
    params = {
        "limit": limit,
        "order": "moment,desc",
        "filter": "state.name=–û—Ç–≥—Ä—É–∂–µ–Ω"
    }
    
    try:
        return _get("entity/demand", params)["rows"]
    except Exception as e:
        log.error(f"Error fetching demands: {e}")
        return []

/Users/ilaeliseenko/Desktop/loyalty-bot/bot/yclients.py

# loyalty-bot/bot/yclients.py
import requests
import locale
from datetime import date
from .config import YCLIENTS_PARTNER_TOKEN

API = "https://api.yclients.com/api/v1"
HEADERS = {
    "Authorization": f"Bearer {YCLIENTS_PARTNER_TOKEN}",
    "Accept":        "application/vnd.yclients.v2+json",
    "Content-Type":  "application/json",
}


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _get(path: str, params: dict | None = None):
    """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π GET: –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ data –∏–∑ –æ—Ç–≤–µ—Ç–∞."""
    r = requests.get(API + path, headers=HEADERS, params=params or {}, timeout=10)
    r.raise_for_status()
    return r.json()["data"]          # <-- –±–µ—Ä—ë–º —Ä–æ–≤–Ω–æ data

def book_dates(company_id: int, **params) -> dict:
    """
    GET /book_dates/{company_id}
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –∫–ª—é—á–∞–º–∏ booking_dates, booking_days, ‚Ä¶
    """
    return _get(f"/book_dates/{company_id}", params)


def _post(path: str, json: dict):
    """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π POST: –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ data –∏–∑ –æ—Ç–≤–µ—Ç–∞."""
    r = requests.post(API + path, headers=HEADERS, json=json, timeout=10)
    r.raise_for_status()
    return r.json()["data"]          # <-- –±–µ—Ä—ë–º —Ä–æ–≤–Ω–æ data


def format_date_russian(date_iso: str) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–∞—Ç—É —Å —Ä—É—Å—Å–∫–∏–º–∏ –º–µ—Å—è—Ü–∞–º–∏."""
    locale.setlocale(locale.LC_TIME, "ru_RU.UTF-8")
    return date.fromisoformat(date_iso).strftime("%d %b (%a)")


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ø—É–±–ª–∏—á–Ω—ã–µ –æ–±—ë—Ä—Ç–∫–∏ API ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def services(company_id: int):
    """GET /book_services/{company_id}"""
    return _get(f"/book_services/{company_id}")


def staff(company_id: int, service_ids: list[int] | None = None):
    """GET /book_staff/{company_id}"""
    params = {}
    if service_ids:
        params["service_ids[]"] = service_ids
    return _get(f"/book_staff/{company_id}", params)


def free_slots(
    company_id: int,
    staff_id:   int,
    service_id: int,
    date_iso:   str,
) -> list[dict]:
    """
    GET /book_times/{company_id}/{staff_id}/{date}
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π –≤–∏–¥–∞:
        {"time": "17:30", "datetime": "2025-06-17T14:30:00+03:00"}
    """
    return _get(
        f"/book_times/{company_id}/{staff_id}/{date_iso}",
        params={"service_ids[]": service_id},
    )


def create_record(
    company_id:      int,
    phone:           str,
    fullname:        str,
    email:           str,
    appointments:    list[dict],
    comment:         str | None = None,
    code:            str | None = None,
    notify_by_sms:   int | None = None,
    notify_by_email: int | None = None,
):
    """POST /book_record/{company_id}"""
    payload = {
        "phone":        phone,
        "fullname":     fullname,
        "email":        email,
        "appointments": appointments,
    }
    if comment:             payload["comment"]          = comment
    if code:                payload["code"]             = code
    if notify_by_sms is not None:
        payload["notify_by_sms"] = notify_by_sms
    if notify_by_email is not None:
        payload["notify_by_email"] = notify_by_email

    return _post(f"/book_record/{company_id}", payload)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def book_services(company_id: int, **params):
    """–°—Ç–∞—Ä–æ–µ –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –∞–ª–∏–∞—Å –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏."""

    return services(company_id, **params)


BOT_TOKEN=7914899311:AAGY4CjuMqZX3w1eS7zCM2yNMW3312xCwPE
MS_TOKEN=ecfb2a801095bded8b05cabbb597bbce3dc59e73